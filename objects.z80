
    struct object
y           byte
x           byte
mirror byte
sprite      word
state       word
spritesheet word
behaviour word
    ends

    struct object_behaviour
tick word
turn word
interact word
draw word
    ends

    module objects

SPRITE_SIZE equ 53

mult_table
    rept 7, idx
    dw idx * SPRITE_SIZE
    endr


hero_behaviour object_behaviour 0, 0, 0, map.draw_object
door_behaviour object_behaviour door_tick, door_turn, door_interact, draw_with_color
item_behaviour object_behaviour 0, item_turn, item_interact, draw_with_color
hero object 1, 1, 0, girl, 0, girl, hero_behaviour
door_1 object 8, 4, 0, door, 0x200, door, door_behaviour
door_2 object 14, 4, 0, door, 0x500, door, door_behaviour
door_3 object 14, 22, 0, door, 0x400, door, door_behaviour
keycard_red object 6, 6, 0, keycard, 0x201, 0, item_behaviour
adjacent_object dw 0

; hl - object list (preserved)
; a - behaviour offset
object_loop:
1
    push hl
    ld b, a
    ld a, (hl)
    inc hl
    ld h, (hl)
    ld l, a
    xor a
    or h
    jr z, 2F
    ld a, b
    push af
    call call_behaviour
    pop af
    pop hl
    .2 inc hl
    jr 1B
2
    pop hl
    ret

; hl - object
; a - behaviour index
; corrupts de and bc
call_behaviour:
    ld d, h
    ld e, l
    ld bc, object.behaviour
    add hl, bc
    ld c, (hl)
    inc hl
    ld h, (hl)
    bit 7, h
    ret z
    ld l, c

    ld c, a
    add hl, bc
    ld c, (hl)
    inc hl
    ld h, (hl)
    bit 7, h
    ret z
    ld l, c

    push hl
    ex de, hl
    ret

interact:
    ld hl, (adjacent_object)
    ld a, h
    or a
    ret z

    ld a, object_behaviour.interact
    jp call_behaviour ; call & ret

item_turn:
    ld ix, hl
    ld a, (ix + object.state + 1)
    ld b, a
    or a
    ret z ; already picked up

    ld a, (hero.x)
    sub (ix + object.x)

    inc a
    cp 3
    ret nc

    ld a, (hero.y)
    sub (ix + object.y)
    inc a
    cp 4
    ret nc

    ld (adjacent_object), hl
    ret

item_interact:
    ld ix, hl
    ld (ix + object.state + 1), 0
    ld (hl), 0xff ; hide
    ld a, (ix + object.state)
    call inventory.add_item
    ld hl, beeper.pickup_sound
    call beeper.play_sfx
    ld a, 1
    ld (dirty_screen), a
    ret

door_turn:
    ld ix, hl
    ld a, (ix + object.state)
    or a
    jr nz, .check_closing

    ld a, (hero.y) ; door.y - 1 <= y <= door.y + 1
    sub (hl)
    inc a
    cp 3
    ret nc

    inc hl
    ld a, (hero.x)
    cp (hl)
    ret nz

    dec hl
    ld (adjacent_object), hl

.check_closing
    cp 0xff
    ret nz

    ; -1, 0, 1

    ; keep open if
    ; -1 <= hero.y - door.y <= 1
    ld a, (hero.y)
    ld b, a
    ld a, (hl)
    and 0x7f ; the 7th bit is used for hiding
    sub b
    inc a
    cp 3
    jr nc, .start_closing

    ; keep open if
    ; -1 <= hero.x - door.x <= 1
    inc hl
    ld a, (hero.x)
    sub (hl)
    inc a
    cp 3
    ret c

.start_closing
    ld (ix + object.state), 0x87
    ld a, (ix)
    and 0x7f
    ld (ix), a ; unhide object
    ret

door_interact:
    ld ix, hl
    ld a, (ix + object.state)
    or a
    ret nz

    ld (ix + object.state), 1
    ret
door_tick:
    ld ix, hl
    ld a, (ix + object.state)
    or a
    ret z

    cp 0xff
    ret z

    bit 7, a
    jr z, .opening

.closing
    and 0x0f
    or a
    jr nz, 1F
    ; ld hl, i18n.door_closed
    ; call console.print_localized
    ld (ix + object.state), 0
    ld a, 1
    ld (dirty_screen), a
    ret

1
    bit 0, a
    jr z, 2F
    dec a
    or 0x80
    ld (ix + object.state), a
    ret

2
    dec a
    or 0x80
    ld (ix + object.state), a
    and 0x7f
    sra a
    call update_sprite
    ret

.opening
    cp 5
    jr nz, 1F
    ; done opening, deactivate the door
    ; ld hl, i18n.door_open
    ; push ix
    ; call console.print_localized
    ; pop ix
    ld a, (ix)
    or 0x80
    ld (ix), a ; hide object by moving it off-screen
    ld (ix + object.state), 0xff
    ld a, 1
    ld (dirty_screen), a
    ret

1
    bit 0, a
    jr z, 2F
    inc a
    ld (ix + object.state), a
    ret

2
    inc a
    ld (ix + object.state), a
    sra a
    call update_sprite
    ret

; hl - door object
draw_with_color:
    push hl
    ld bc, object.state + 1
    add hl, bc
    ld a, (hl)
    .3 dec hl
    ld b, (hl)
    inc hl
    ld h, (hl)
    ld l, b
    call sprite.paint_sprite_monochrome
    pop hl
    jp map.draw_static_object

;; ix - character (preserved)
;; a - sprite number
;; corrupts: hl, de
update_sprite:
    ld e, a
    ld d, 0
    ld hl, mult_table
    add hl, de
    add hl, de
    ld e, (hl)
    inc hl
    ld h, (hl)
    ld l, e

    ld e, (ix + object.spritesheet)
    ld d, (ix + object.spritesheet + 1)

    add hl, de

    ld (ix + object.sprite), l
    ld (ix + object.sprite + 1), h

    ld a, 1
    ld (dirty_screen), a
    ret


    endmodule
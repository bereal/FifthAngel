com	module map

	;; sizes in tiles
	define MapSize 32
	define BufferAddr 0xc000
	define Buffer_TW 12
	define Buffer_TH 12
	define VisibleBuffer_TW 11
	define VisibleBuffer_TH 11

	define BufferedCellSize 3
	define TileSize 2
	define TileRowSize 6
	define BufferRowSize TileRowSize * Buffer_TW
	define BufferSize BufferRowSize * Buffer_TH * TileSize
	define LastTileRowOffset TileRowSize * (Buffer_TH - 1) * Buffer_TW * TileSize

	define RecoveryQueue BufferAddr + BufferSize

	align 2
buffer_lines:
	rept Buffer_TH * TileSize, line
		dw BufferAddr + line * BufferRowSize
	endr

screen_lines:
	rept 12, line
		dw 0x4000 + line * 32
	endr
	rept 12, line
		dw 0x4800 + line * 32
	endr
	rept 8, line
		dw 0x5000 + line * 32
	endr

@dirty_screen:
	db 0

visible_offset:
.column db 0
.row db 0

	align 4
visible_buffer_bounds:
.min.x db 0
.max.x db 0
.min.y db 0
.max.y db 0

visible_map_coord:
.x db 0
.y db 0

buffered_map_coord:
.x db 0
.y db 0

recovery_queue_tail:
	dw RecoveryQueue

map_coord:
.x db 0
.y db 0

buffered_map_addr:
	dw test_level

test_level:
	include "res/test_level.z80"

	macro resolve_tile
		ld a, (hl)
		ld hl, tiles_table
		ld c, a
		ld b, 0
		add hl, bc
		add hl, bc

		ld a, (hl)
		inc hl
		ld h, (hl)
		ld l, a
	endm

	macro prepare_tile
		resolve_tile

		.TileRowSize ldi

		ex de, hl
		ld bc, TileRowSize * (Buffer_TW - 1)
		add hl, bc
		ex de, hl

		.TileRowSize ldi
	endm


; in: bc - coords as b=x, c=y
; out: hl - buffer address
;      flag M if out of screen
coord_to_addr:
	ld a, (visible_buffer_bounds.min.y)
	sub c
	ld c, a
	ld a, (visible_offset.row)
	sub c
	ld c, a

	jp m, .end

	ld c, a
	ld a, b

	ld b, 0
	ld hl, buffer_lines
	add hl, bc
	add hl, bc

	ld b, (hl)
	inc l
	ld h, (hl)
	ld l, b

	ld c, a

	ld a, (visible_buffer_bounds.min.x)
	ld b, a
	ld a, (visible_offset.column)
	sub b
	add c

	jp m, .end

	; hl += 3 * bc
	ld b, 0
	ld c, a
	add hl, bc
	sla c
	add hl, bc

.end
	ret


; hl - object address
@draw_object:
	ld b, (hl) ; x
	inc l
	ld c, (hl) ; y
	inc l

	call coord_to_addr
	jp m, .end

	call save_tile

	ld a, (hl)
	and 0x7f
	or a
	jr nz, 1F
	ld (hl), 0xff
	jp 2F
1
	ld (hl), 0b11101101
2
	.3 inc hl

	ld a, (hl)
	and 0x7f
	or a
	jr nz, 1F
	ld (hl), 0xff
	jp 2F
1
 	ld (hl), 0b11101101

2

	ld bc, BufferRowSize - BufferedCellSize
	add hl, bc
	ld a, (hl)
	or a
	jp nz, 1F
	ld (hl), 0b11101101
1
	.3 inc hl
	ld a, (hl)
	or a
	jp nz, 2F
	ld (hl), 0b11101101
2

.end
	ret

prepare_map_row:
	ld b, Buffer_TW
.loop
	push bc
	push hl

	prepare_tile

	ex de, hl
	ld bc, - TileRowSize * Buffer_TW
	add hl, bc
	ex de, hl

	pop hl
	inc hl
	pop bc
	djnz .loop

	ret

prepare_map_column:
	ld b, Buffer_TW
.loop
	push bc
	push hl

	prepare_tile

	ex de, hl
	ld bc, TileRowSize * (Buffer_TW - 1)
	add hl, bc
	ex de, hl


	pop hl
	ld bc, MapSize
	add hl, bc
	pop bc
	djnz .loop

	ret

; assume that the buffer is scrolled maximum to the right
scroll_buffer_right:
	di
	ld hl, BufferAddr + TileRowSize
	ld de, BufferAddr
	exx
	ld b, Buffer_TH * TileSize
.loop
	exx
	ld bc, BufferRowSize - TileRowSize
	ldir

	ld bc, TileRowSize
	add hl, bc
	ex de, hl
	add hl, bc
	ex de, hl
	exx
	djnz .loop

	ld hl, (buffered_map_addr)
	inc hl
	ld (buffered_map_addr), hl

	; draw missing column on the right
	ld bc, Buffer_TW - 1
	add hl, bc
	ld de, BufferAddr + BufferRowSize - TileRowSize
	call prepare_map_column
	ei
	ret

scroll_buffer_left:
	di
	ld hl, BufferAddr + BufferRowSize - TileRowSize - 1
	ld de, BufferAddr + BufferRowSize - 1
	exx
	ld b, Buffer_TH * TileSize

.loop
	exx
	ld bc, (Buffer_TW - 1) * TileRowSize
	lddr
	ld bc, TileRowSize * (2 * Buffer_TW - 1)
	add hl, bc
	ex de, hl
	add hl, bc
	ex de, hl
	exx
	djnz .loop

	ld hl, (buffered_map_addr)
	dec hl
	ld (buffered_map_addr), hl

	ld de, BufferAddr
	call prepare_map_column

	ei
	ret

scroll_buffer_down:
	di
	ld hl, BufferAddr + BufferRowSize * TileSize
	ld de, BufferAddr
	ld bc, LastTileRowOffset
	ldir

	ld hl, (buffered_map_addr)
	ld bc, MapSize
	add hl, bc
	ld (buffered_map_addr), hl

	; draw missing row on the bottom
	ld bc, MapSize * (Buffer_TW - 1)
	add hl, bc
	ld de, BufferAddr + LastTileRowOffset
	call prepare_map_row
	ei
	ret

scroll_buffer_up:
	di
	ld hl, BufferAddr + BufferSize - BufferRowSize * TileSize - 1
	ld de, BufferAddr + BufferSize - 1
	ld bc, BufferSize - BufferRowSize * TileSize
	lddr

	ld hl, (buffered_map_addr)
	ld bc, -MapSize
	add hl, bc
	ld (buffered_map_addr), hl

	ld de, BufferAddr
	call prepare_map_row
	ei
	ret

@redraw_map:
	di
	ld hl, (buffered_map_addr)
	ld de, BufferAddr
	ld b, Buffer_TH

.loop
	push bc
	call prepare_map_row
	ld bc, MapSize - Buffer_TW
	add hl, bc
	ex de, hl
	ld bc, BufferRowSize
	add hl, bc
	ex de, hl
	pop bc
	djnz .loop
	ld a, 1
	ld (dirty_screen), a
	ei
	ret

reset_full_redraw:
	ld hl, 0x79cb ; CB 79 = bit 7, c
	ld (copy_line.check_dirty), hl
	ret

set_full_redraw:
	ld hl, 0
	ld (copy_line.check_dirty), hl
	ret


;; hl - buffer address
;; de - attr address
;; hl' - bitmap address
;; bc' - 0xf901
copy_line:
	ld (.ret + 1), sp
	ld b, 22
.loop
	ld a, (hl)
	inc hl

	and 0x7f
	cp 0x7f
	jp nz, 1F
	ld a, 0b01101101
	ld (de), a
	inc de
	jp .skipdraw

; 	ld a, 0b11101101
; 	ld (de), a
; 	jr .skipdraw
1
	ld (de), a
	inc de
	or a
	jr z, .skipdraw

.check_dirty
	nop
	nop
	jr z, .skipdraw

.draw_cell
	ld a, (hl)
	ld (.setsp+1), a
	inc hl
	ld a, (hl)
	ld (.setsp+2), a
	inc hl
	exx
.setsp
	ld sp, 0

	rept 4, idx
		pop de
		ld (hl), e
		inc h
		ld (hl), d
		if idx < 3
			inc h
		endif
	endr

	add hl, bc
	exx
	djnz .loop
	jp .ret

.skipdraw
	inc hl
	inc hl
	exx
	inc l
	exx
	djnz .loop
.ret
	ld sp, 0
  	ret

	macro do_copy_line bitmap_row, attr_high_byte
		; ld hl, (buf_addr)
		ld de, attr_high_byte * 0x100 + low(bitmap_row)
		exx
		ld hl, bitmap_row
		exx
		call copy_line
	endm

	macro next_line
		ld bc, (Buffer_TW - VisibleBuffer_TW) * 6
		add hl, bc
	endm

@copy_buffer:
.set_border
	ld a, 0
	out (254), a

	exx
	ld bc, 0xf901
	exx

	ld hl, (visible_offset)
	ld b, h
	ld d, 0
	ld e, l
	ld hl, BufferAddr
	.3 add hl, de

	xor a
	or b
	jr z, 2F
	ld de, BufferRowSize
1
	add hl, de
	djnz 1B
2

	do_copy_line 0x4000, 0x58
	next_line

	do_copy_line 0x4020, 0x58
	next_line

	do_copy_line 0x4040, 0x58
	next_line

	do_copy_line 0x4060, 0x58
	next_line

	do_copy_line 0x4080, 0x58
	next_line

	do_copy_line 0x40a0, 0x58
	next_line

	do_copy_line 0x40c0, 0x58
	next_line

	do_copy_line 0x40e0, 0x58
	next_line

	do_copy_line 0x4800, 0x59
	next_line

	do_copy_line 0x4820, 0x59
	next_line

	do_copy_line 0x4840, 0x59
	next_line

	do_copy_line 0x4860, 0x59
	next_line

	do_copy_line 0x4880, 0x59
	next_line

	do_copy_line 0x48a0, 0x59
	next_line

	do_copy_line 0x48c0, 0x59
	next_line

	do_copy_line 0x48e0, 0x59
	next_line

	do_copy_line 0x5000, 0x5a
	next_line

	do_copy_line 0x5020, 0x5a
	next_line

	do_copy_line 0x5040, 0x5a
	next_line

	do_copy_line 0x5060, 0x5a
	next_line

	do_copy_line 0x5080, 0x5a
	next_line

	do_copy_line 0x50a0, 0x5a

	ld a, 0
	out (254), a

	call reset_full_redraw
	ret


; hl - buffer addr (preserved)
save_tile:
	push hl
	push de
	push bc
	ex de, hl

	ld hl, (recovery_queue_tail)
	ld (hl), e
	inc hl
	ld (hl), d
	inc hl

	ex de, hl

	.BufferedCellSize ldi

	ex de, hl
	ld (hl), e
	inc hl
	ld (hl), d
	inc hl
	ex de, hl

	.BufferedCellSize ldi

	ld bc, BufferRowSize - 2 * BufferedCellSize
	add hl, bc

	ex de, hl
	ld  (hl), e
	inc hl
	ld (hl), d
	inc hl
	ex de, hl

	.BufferedCellSize ldi

	ex de, hl
	ld (hl), e
	inc hl
	ld (hl), d
	inc hl
	ex de, hl

	.BufferedCellSize ldi

	ex de, hl
	ld (recovery_queue_tail), hl
	pop bc
	pop de
	pop hl
	ret

@recover_buffer:
	ld hl, RecoveryQueue
	ld (recovery_queue_tail), hl
.loop
	ld e, (hl)
	inc hl

	ld a, (hl)
	or a
	jr z, .cleanup
	ld d, a

	inc hl
	.BufferedCellSize ldi
	jp .loop

.cleanup
	ld bc, 0x10000-(RecoveryQueue)
	add hl, bc
	ld a, l
	or h
	ret z
	ld b, h
	ld c, l
	ld hl, RecoveryQueue
	ld de, RecoveryQueue + 1
	ld (hl), 0
	ldir
	ret

scroll_map_right:
	call recover_buffer

	ld a, (map_coord.x)
	inc a
	cp MapSize * 2 - VisibleBuffer_TW * 2 + 1
	ret z
	ld (map_coord.x), a

	ld hl, visible_buffer_bounds.min.x
	inc (hl)
	inc l
	inc (hl)

	ld hl, visible_map_coord.x
	inc (hl)

	ld a, (visible_offset.column)
	inc a
	cp 3
	jr nz, .noredraw
	call scroll_buffer_right
	ld a, 1

.noredraw
	ld (visible_offset.column), a
	ld (dirty_screen), a

	call set_full_redraw
	ret

scroll_map_left:
	call recover_buffer

	ld a, (map_coord.x)
	dec a
	ret m
	ld (map_coord.x), a

	ld hl, visible_buffer_bounds.min.x
	dec (hl)
	inc l
	dec (hl)

	ld hl, visible_map_coord.x
	dec (hl)

	ld a, (visible_offset.column)
	sub 1
	jr nc,	.noredraw
	call scroll_buffer_left
	ld a, 1

.noredraw
	ld (visible_offset.column), a
	inc a
	ld (dirty_screen), a

	call set_full_redraw
	ret

scroll_map_down:
	call recover_buffer

	ld a, (map_coord.y)
	inc a
	cp MapSize * 2 - VisibleBuffer_TH * 2 + 1
	ret z
	ld (map_coord.y), a

	ld hl, visible_buffer_bounds.min.y
	inc (hl)
	inc l
	inc (hl)

	ld a, (visible_offset + 1)
	inc a
	cp 3
	jr nz, .noredraw
	call scroll_buffer_down
	ld a, 1

.noredraw
	ld (dirty_screen), a
	ld (visible_offset.row), a
	ld (dirty_screen), a

	call set_full_redraw
	ret

@scroll_map_up:
	call recover_buffer

	ld a, (map_coord.y)
	dec a
	ret m
	ld (map_coord.y), a

	ld hl, visible_buffer_bounds.min.y
	dec (hl)
	inc l
	dec (hl)

	ld a, (visible_offset + 1)
	sub 1
	jr nc,	.noredraw
	call scroll_buffer_up
	ld a, 1

.noredraw
	ld (visible_offset.row), a
	inc a
	ld (dirty_screen), a

	call set_full_redraw
	ret

@move_hero_up:
	ld hl, (hero.x)
	dec h
	ret m

	push hl
	ld c, h
	ld b, l
	inc c
	call coord_to_addr
	ld a, (hl)
	cp 0xff
	jr nz, 1F
	ld bc, 3
	add hl, bc
	ld a, (hl)
	cp 0xff
1
	pop hl
	ret nz

	ld (hero.x), hl
	ld a, h
	cp 64 - 12
	call c, scroll_map_up

	ld a, 1
	ld (dirty_screen), a
	ret

@move_hero_down:
	ld hl, (hero.x)
	inc h
	ld a, h
	cp MapSize * 2 - 3
	ret z

	and 1
	jr nz, .aftercheck

	push hl
	ld c, h
	ld b, l
	inc c

	call coord_to_addr

	ld a, (hl)
	ld bc, 3
	add hl, bc
	or (hl)
	and 0x7f

	pop hl
	ret nz

.aftercheck
	ld (hero.x), hl

	ld a, h
	cp 12
	call nc, scroll_map_down

	ld a, 1
	ld (dirty_screen), a
	ret

@move_hero_right:
	ld hl, (hero.x)
	inc l
	ld a, l
	cp MapSize * 2 - 3
	ret z

	push hl
	ld c, h
	ld b, l
	inc b

	push bc
	call coord_to_addr
	pop bc

	ld a, c
	and 1
	jr z, 1F

	ld a, (hl)
	and 0x7f
	jr z, .checked

1
	ld bc, BufferRowSize
	add hl, bc
	ld a, (hl)
	and 0x7f

.checked
	pop hl
	ret nz

	ld b, l
	ld c, h

	ld a, l
	ld (hero.x), a
	cp 12

	call nc, scroll_map_right

	ld a, 1
	ld (dirty_screen), a
	ret

@move_hero_left:
	ld hl, (hero.x)
	ld a, l
	or a
	ret z
	dec l
	ld a, l

	push hl
	ld c, h
	ld b, l

	push bc
	call coord_to_addr
	pop bc

	ld a, c
	and 1
	jr z, 1F

	ld a, (hl)
	and 0x7f
	jr z, .checked

1
	ld bc, BufferRowSize
	add hl, bc
	ld a, (hl)
	and 0x7f

.checked
	pop hl
	ret nz

	ld b, l
	ld c, h

	ld a, l
	ld (hero.x), a
	cp 64 - 12
	call c, scroll_map_left

	ld a, 1
	ld (dirty_screen), a
	ret

; set Z iff the location can be occupied by a hero
can_occupy_tile:
	push hl
	inc h
	; ld a, 1
	; and l
	; jr z, .ret

	ld a, l

	ld b, 0
	ld c, h

	ld hl, buffer_lines
	add hl, bc
	add hl, bc
	ld c, (hl)
	inc hl
	ld h, (hl)
	ld l, c
	ld c, a
	add hl, bc
	sla c
	add hl, bc

	ld a, (hl)
	ld c, 3
	add hl, bc
	or (hl)
	and 0x7f

.ret
	pop hl
	ret
	endmodule
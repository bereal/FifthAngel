	; a map is first drawn to a shadow buffer of size 12x12 tiles (24x24 cells)
	; because scroll is per cell, there's a 'camera offset' 0, 1 or 2
	; the result shadow screen offset is then high(view_offset) * 12 * 8 + low(view_offset)

	; units: 2 steps = 1 tile, all coords is by default in steps


	;; the map size is everywhere assumed to be 32x32
	define MAP_SIZE 64
	define SHADOW_BUFFER 0xc000

map_addr:
	dw map

map_coord:
	db 0, 0

drawn_coord:  ; top-left tile that's drawn in the shadow buffer (aligned to a tile)
	db 0, 0

visible_buffer_addr:
	dw 0

calc_view_offset:
	ld hl, (map_coord)
	ex de, hl
	ld hl, (drawn_coord)

	ld a, d
	sub h
	ld h, a

	ld a, e
	sub l
	ld l, a
	ret

sync_shadow_buffer:
	call calc_view_offset

;   ld a, h
; 	cp 3
; 	jr nc, .full_redraw
; 	ld a, l
; 	cp 3
; 	jr nc, .full_redraw

; 	; update shadow buffer start address
; 	ex de, hl
; 	ld hl, SHADOW_BUFFER
; 	ld a, d
; 	or a
; 	jr z, 2F
; 	ld bc, 24 * 8  ;; next row

; 1
; 	add hl, bc
; 	dec d
; 	jr nz, 1B

; 2
; 	add hl, de
; 	ld (shadow_buffer_addr), hl
; 	ret

.full_redraw
	ld hl, SHADOW_BUFFER
	ld (visible_buffer_addr), hl

	ld hl, (map_coord)
	res 0, h
	res 0, l
	ld (drawn_coord), hl
	ex de, hl

	call redraw_map
	ret


copy_buffer_to_screen:
	halt

	ld a, 2
	out (254), a
	di
	ld hl, (visible_buffer_addr)
	ld a, b
	ld b, 0

	ld (.ret+1), sp

	exx
	ld hl, 0x4000

.loop:
	ld (.restore_output_2 + 1), hl
	exx

	; read 12 bytes
	ld sp, hl
	pop af
	pop bc
	pop de
	exx
	ex af, af'
	ld bc, 12
	add hl, bc
	pop af
	pop bc
	pop de

	ld (.restore_input_1 + 1), sp
	ld sp, hl

	; write 12 bytes
	push de
	push bc
	push af
	exx
	ex af, af'
	push de
	push bc
	push af

.restore_input_1:
	ld hl, 0
	ld sp, hl

	; read 10 bytes
	pop af
	pop bc
	pop de
	exx
	ex af, af'
	ld bc, 10
	add hl, bc
	pop bc
	pop de
	pop af ;;

	ld (.restore_input_2 + 1), sp
	ld sp, hl

	push de
	push bc
	exx
	ex af, af'
	push de
	push bc
	push af

.restore_input_2:
	ld hl, 0
	exx

.restore_output_2:
	ld hl, 0
	inc h
	ld a, 7
	and h
	jr nz, .loop
	ld a, h
	sub 8
	ld h, a
	cp 0x50
	jr z, .ret
	ld a, l
	add 0x20
	ld l, a
	jr nc, .loop
	ld a, h
	add a, 8
	ld h, a
	cp 0x58
	jp nz, .loop

.ret
	ld sp, 0
	ei
	ld a, 0
	out (254), a
	ret

;;  in:
;;	  (hl) - tile number
;;    de - screen address
;;    ix - attribute address
;;    z flag - draw only attrs
draw_tile:
	ld a, (hl)
	ld c, a
	ld b, 0
	ld hl, tiles_pallette
	add hl, bc
	add hl, bc
	ld ($+4), hl ; hl = (hl)
	ld hl, (0)

	ld (.ret+1), sp
	ld sp, hl
	ex de, hl
	ld bc, 24

	rept 8, idx
		pop de
		ld (hl), e
		inc l
		ld (hl), d
		add hl, bc
		pop de
		ld (hl), d
		dec l
		ld (hl), e

		if idx < 7
			add hl, bc
		endif
	endr

	; copy_8_tile_lines_to_buffer

	; ld bc, 0xf920
	; add hl, bc

	; copy_8_tile_lines_to_buffer

.draw_attrs
	; pop hl
	; ld (ix), l
	; ld (ix+1), h
	; pop hl
	; ld (ix+32), l
	; ld (ix+33), h

.ret
	ld sp, 0
	ret

redraw_map:
	di
	ld hl, (map_addr)

	rept 12, idx
		push hl
		; ld hl, map_addr + 11 * idx
		ld de, SHADOW_BUFFER + 12 * 4 * 8 * idx
		call draw_map_row
		pop hl
		ld bc, 32
		add hl, bc
	endr
	ei

.ret
	ret

draw_hero:
; 	ld de, SHADOW_BUFFER + 11 * 4 * 8 * 5 + 6 * 2; 0x4800 + 32 * 2 + 12
; 	ld ix, 0x5800 + 32 * 10 + 12
; 	or d  ;; set z = 0
.sethero
	ld hl, hero_right
; 	call draw_tile
	ret

@scroll_map_down:
	ld hl, (map_coord)
	ld a, h
	inc a
	cp MAP_SIZE
	ret z
	ld h, a
	ld (map_coord), hl

	and 1
	jr z, .next_tile

	ld hl, SHADOW_BUFFER + 12 * 2 * 8
	ld (visible_buffer_addr), hl
	jr .draw

.next_tile
	ld hl, (map_addr)
	ld bc, MAP_SIZE / 2
	add hl, bc
	ld (map_addr), hl
	ld hl, SHADOW_BUFFER
	ld (visible_buffer_addr), hl

.draw
	call redraw_map
	call copy_buffer_to_screen

	ret

@scroll_map_up:
	ld hl, (map_coord)
	dec h
	ret m
	ld (map_coord), hl

	bit 0, h
	jr nz, .prev_tile

	ld hl, SHADOW_BUFFER
	ld (visible_buffer_addr), hl
	jr .draw

.prev_tile:
	ld hl, (map_addr)
	xor a
	ld bc, MAP_SIZE / 2
	sbc hl, bc
	ld (map_addr), hl
	ld hl, SHADOW_BUFFER + 12 * 2 * 8
	ld (visible_buffer_addr), hl

.draw
	call redraw_map
	call copy_buffer_to_screen
	ret

@scroll_map_left:
	ld hl, (map_coord)
	dec l
	ret m
	ld (map_coord), hl

	bit 0, l
	jr nz, .prev_tile

	ld hl, SHADOW_BUFFER
	ld (visible_buffer_addr), hl
	jr .draw

.prev_tile:
	ld hl, (map_addr)
	dec hl
	ld (map_addr), hl
	ld hl, SHADOW_BUFFER + 1
	ld (visible_buffer_addr), hl

.draw
	call redraw_map
	call copy_buffer_to_screen
	ret

@move_right:
	ld hl, (map_coord)
	ld a, l
	inc a
	cp MAP_SIZE
	ret z

	ld l, a
	ld (map_coord), hl

	and 1
	jr z, .next_tile

	ld hl, SHADOW_BUFFER + 1
	ld (visible_buffer_addr), hl
	jr .draw

.next_tile:
	ld hl, (map_addr)
	inc hl
	ld (map_addr), hl

	ld hl, SHADOW_BUFFER
	ld (visible_buffer_addr), hl

.draw:
	call redraw_map
	call copy_buffer_to_screen
	ret


;; hl - map row address
;; de - shadow buffer row address
draw_map_row:
	ld b, 12

.loop
	push hl
	push bc
	push de
	call draw_tile
	pop de
	pop bc
	pop hl

	inc hl
	.2 inc de
	djnz .loop

	ret

init_map:
	ld hl, 0x5800
	ld de, 0x5801
	ld (hl), 15
	ld bc, 255
	ldir

	ld hl, 0x5900
	ld de, 0x5901
	ld (hl), 23
	ld bc, 255
	ldir


	ld hl, map
	ld (map_addr), hl
	ld hl, 0
	ld (map_coord), hl
	ld (drawn_coord), hl
	ld hl, SHADOW_BUFFER
	ld (visible_buffer_addr), hl

	call redraw_map
	call copy_buffer_to_screen
	ret


;; in: de - map row addr
;;     hl - buffer row addr
;; buffer structure: 11 * 9 entries
;;   1 byte - current tile (with high bit set if the tile is hidden)
;;   1 byte - pending action (e.g. draw, hide, unhide, keep, draw_hero)
;;   2 byte - tile data address (passed to the action as hl)
copy_map_row_to_buffer:
	ld b, 11

.loop
	ld a, (de)
	ld c, (hl)

	cp c
	jr z, .noop  ; same tile, do nothing

	jr .full_redraw

	bit 7, c
	jr z, .not_hidden

	or a
	jr z, .noop  ; already hidden

	or 0b10000000
	cp (hl)
	res 7, a
	jr nz, .full_redraw

.unhide
	ld (hl), a
	inc hl
	ld (hl), 2
	inc hl

	;; todo: unhide here
	push bc
	push de
	ex de, hl
	ld b, 0
	ld c, a
	ld hl, tiles_pallette
	add hl, bc
	add hl, bc
	ld ($+4), hl ; hl = (hl)
	ld hl, (0)

	ld bc, 0x20
	add hl, bc

	ex de, hl ; de - tile data address

	ld (hl), e
	inc hl
	ld (hl), d
	inc hl

	pop de
	pop bc

	inc de
	djnz .loop
	ret

.not_hidden
	or a
	jr nz, .full_redraw

.hide:
	ld a, 0b10000000
	or c
	ld (hl), a
	inc hl
	ld (hl), 1

	.3 inc hl
	inc de
	djnz .loop
	ret

.noop:
	inc hl
	xor a
	ld (hl), a
	.3 inc hl
	inc de
	djnz .loop
	ret

.full_redraw:
	ld (hl), a
	inc hl
	ld (hl), 3
	inc hl

	push bc
	push de

	ex de, hl
	ld b, 0
	ld c, a
	ld hl, tiles_pallette
	add hl, bc
	add hl, bc
	ld ($+4), hl ; hl = (hl)
	ld hl, (0)
	ex de, hl ; de - tile data address

	ld (hl), e
	inc hl
	ld (hl), d
	inc hl

	pop de
	pop bc

	inc de
	djnz .loop
	ret

;map:
;incbin "res/maze.bin"

map:
	include "test_level.z80"
	include "res/tiles_palette.z80"

;tiles_pallette:
;	dw 0
;	dw wall_1


;wall_1: incbin "res/tiles/wall1.bin"
;	.4 db 7

;wall_2: incbin "res/tiles/wall2.bin"
;	.4 db 7

hero_right:
	incbin "res/cat-right.bin"
	.4 db 0x47

hero_left:
	incbin "res/cat-left.bin"
	.4 db 0x47


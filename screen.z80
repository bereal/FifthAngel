    module screen

bitmap_lookup_table:
    dw 0x4000, 0x4020, 0x4040, 0x4060, 0x4080, 0x40A0, 0x40C0, 0x40E0
    dw 0x4800, 0x4820, 0x4840, 0x4860, 0x4880, 0x48A0, 0x48C0, 0x48E0
    dw 0x5000, 0x5020, 0x5040, 0x5060, 0x5080, 0x50A0, 0x50C0, 0x50E0

align_1:
    align 256
    display "bytes lost due to screen module alignment: ", /D, $-align_1
invert_attr_table:
    db 0x0, 0x8, 0x10, 0x18, 0x20, 0x28, 0x30, 0x38
    db 0x1, 0x9, 0x11, 0x19, 0x21, 0x29, 0x31, 0x39
    db 0x2, 0xa, 0x12, 0x1a, 0x22, 0x2a, 0x32, 0x3a
    db 0x3, 0xb, 0x13, 0x1b, 0x23, 0x2b, 0x33, 0x3b
    db 0x4, 0xc, 0x14, 0x1c, 0x24, 0x2c, 0x34, 0x3c
    db 0x5, 0xd, 0x15, 0x1d, 0x25, 0x2d, 0x35, 0x3d
    db 0x6, 0xe, 0x16, 0x1e, 0x26, 0x2e, 0x36, 0x3e
    db 0x7, 0xf, 0x17, 0x1f, 0x27, 0x2f, 0x37, 0x3f

    struct area
bitmap word
attr word
column byte
row byte
height byte
width byte
    ends



;; ix - area
;; hl - row / col
;; de - width / height
init_area:
    push de
    push hl

    ld (ix + area.column), hl
    ld (ix + area.height), de

	call pos_to_bitmap_addr
	ld (ix + area.bitmap), hl
    pop hl
    push hl

    call pos_to_attr_addr
    ld (ix + area.attr), hl

    pop hl
    pop de

    ret


; ix - area
; a - attribute
set_area_attr:
    push hl
    push de
    push bc
    ld hl, (ix + area.attr)
    ex af, af'
    ld a, (ix + area.width)
    dec a
    ld (.set_width+1), a
    ex af, af'
    ld b, (ix + area.height)

.loop
    push bc
    push hl
.set_width
    ld bc, 0
    ld de, hl
    ld (hl), a
    inc de
    ldir
    pop hl
    ld bc, 0x20
    add hl, bc
    pop bc
    djnz .loop
    pop bc
    pop de
    pop hl
    ret

; h = row, l = column
pos_to_bitmap_addr:
    push af
    push de
    ld a, l
    ld d, 0
    ld e, h
    ld hl, bitmap_lookup_table
    .2 add hl, de

    ld e, (hl)
    inc hl
    ld h, (hl)
    ld l, e

    ld e, a
    add hl, de
    pop de
    pop af
    ret

; h = row, l = column
pos_to_attr_addr:
    ld a, l
    ld d, 0
    ld e, h
    ex de, hl
    .5 add hl, hl
    add hl, de
    ld de, 0x5800
    add hl, de
    ret

    macro down_row X, Y
        ld a, Y
        add 0x20
        ld Y, a
        jr nc, 1F
        ld a, X
        add 8
        ld X, a
1
    endm

    ; after inc X, correct XY if it's out of the cell row
    macro correct_down_line X, Y
        ld a, Y
        add 0x20
        ld Y, a
        jr c, 1F
        ld a, X
        sub 8
        ld h, a
1
    endm

    ; convert pixel addr in hl to attr addr, corrupts a
    macro pixel_to_attr
        ld a, h
        and 0b11000
        .3 srl a
        or 0x58
        ld h, a
    endm

; ix - area
scroll_area_up:
    push hl, bc, de, af
    ld l, (ix + area.bitmap)
    ld h, (ix + area.bitmap + 1)

    ld a, (ix + area.height)
    dec a
    ld b, a
    ld a, 8
    jp z, .clear

    ld e, l
    ld d, h
    down_row h, l

.loop
    push bc
    ld b, 0
    push hl
    push de

    rept 8, idx
    push hl
    push de

    ld c, (ix + area.width)
    ldir

    pop de
    pop hl

    if idx < 7
    inc h
    inc d
    endif
    endr

    pop de
    pop hl

    down_row d, e
    down_row h, l

    pop bc
    djnz .loop

    ; clean the last row
    ex de, hl
    ld a, 8

.clear
    push hl

    ld d, h
    ld e, l
    inc de
    ld c, (ix + area.width)
    dec c
    ld (hl), b
    ldir

    pop hl
    inc h

    dec a
    jr nz, .clear

    pop af, de, bc, hl
    ret


; ix - area
clean_area:
    ld a, (ix + area.width)
    dec a
    ld (.set_width+1), a
    ld b, (ix + area.height)
    ld hl, (ix + area.bitmap)

.loop
    push bc

    ld b, 8
.row_loop
    push bc
    push hl
    ld de, hl
    inc de
    ld (hl), 0
.set_width
    ld bc, 0
    ldir
    pop hl
    pop bc
    inc h
    djnz .row_loop

    correct_down_line h, l
    pop bc
    djnz .loop
    ret

; set_area_attr:
;     ld hl, 0x20
;     ld d, 0
;     ld a, (ix + area.width)
;     ld (.set_width+1), a
;     ld e, a

;     or a
;     sbc hl, de
;     ex de, hl

;     ld hl, (ix + area.attr)

;     ld c, (ix + area.width)


; ix - area
; a - row withih area
invert_row:
    push af
    push bc
    push de
    push hl
    ld hl, (ix + area.attr)
    ld de, 0x20
    or a
    jr z, 2F

    ld b, a
1
    add hl, de
    djnz 1B
2

    ld b, (ix + area.width)
    ld d, high(screen.invert_attr_table)

.loop
    push bc
    ld a, (hl)
    ld c, a
    and 0xc0
    ld b, a
    ld a, c
    and 0x3f

    ld e, a
    ld a, (de)
    or b

    ld (hl), a
    inc l

    pop bc
    djnz .loop
    pop hl
    pop de
    pop bc
    pop af
    ret

border_corner_top_left:
	dg .xxxxxx.
	dg .xxxxxx.
	dg .xx.....
	dg .xx.....
	dg .xx.....
	dg .xx.....
	dg .xx.....
	dg ........

border_corner_top_right:
	dg .xxxxxx.
	dg .xxxxxx.
	dg .....xx.
	dg .....xx.
	dg .....xx.
	dg .....xx.
	dg .....xx.
	dg ........

border_corner_bottom_left:
	dg ........
	dg .xx.....
	dg .xx.....
	dg .xx.....
	dg .xx.....
	dg .xx.....
	dg .xxxxxx.
	dg .xxxxxx.

border_corner_bottom_right:
	dg ........
	dg .....xx.
	dg .....xx.
	dg .....xx.
	dg .....xx.
	dg .....xx.
	dg .xxxxxx.
	dg .xxxxxx.

border_top:
	db 0xff, 0xff, 0, 0, 0, 0, 0, 0

border_bottom:
	db 0, 0, 0, 0, 0, 0, 0xff, 0xff

border_right:
	.8 dg .....xx.
border_left:
	.8 dg .xx.....

draw_cell
	push bc
	ld b, 8
1
	ld a, (de)
	ld (hl), a
	inc h
	inc de
	djnz 1B
	pop bc
	ret


; ix - area addr
draw_area_border:
    ld hl, (ix + area.bitmap)
    ld bc, -0x21
    add hl, bc
    ld bc, (ix + area.height)

	push bc
	push hl
	; draw top left corner
	ld de, border_corner_top_left
	push hl
	call draw_cell
	pop hl

	; draw horizontal line
	inc hl
	push bc
1
	ld de, border_top
	push hl
	call draw_cell
	pop hl
	inc hl
	djnz 1B

	ld de, border_corner_top_right
	call draw_cell
	correct_down_line h, l

2
	ld de, border_right
	call draw_cell
	correct_down_line h, l
	dec c
	jr nz, 2B

	pop bc

	ld de, border_corner_bottom_right
	call draw_cell

	pop hl
	down_row h, l
3
	ld de, border_left
	call draw_cell
	correct_down_line h, l
	dec c
	jr nz, 3B


	push hl
	ld de, border_corner_bottom_left
	call draw_cell
	pop hl
	pop bc

	; draw bottom horizontal line
	inc hl
1
	ld de, border_bottom
	push hl
	call draw_cell
	pop hl
	inc hl
	djnz 1B
	ret


; ix - area
color_area_border:
    push af
    push bc
    push de
    push hl
    ld hl, (ix + area.attr)
    ld bc, -0x21
    add hl, bc
    ld bc, (ix + area.height)
    push hl
    push bc
    ld c, b
    ld b, 0
    inc c
    ld de, hl
    inc e
    ld (hl), a
    ldir

    pop bc
    push bc
    ld de, 0x20
    add hl, de

1
    ld (hl), a
    add hl, de
    dec c
    jr nz, 1B

    pop bc
    pop hl
    push bc
    add hl, de
    inc c

2
    ld (hl), a
    add hl, de
    dec c
    jr nz, 2B

    pop bc
    sbc hl, de

    ld d, h
    ld e, l
    inc e
    ld c, b
    ld b, 0
    inc c
    ldir

    pop hl
    pop de
    pop bc
    pop af
    ret

    endmodule
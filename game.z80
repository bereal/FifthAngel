    module game

PHASE_FACE_STAND       equ 0
PHASE_FACE_WALK        equ 1
PHASE_BACK_STAND       equ 2
PHASE_BACK_WALK        equ 3
PHASE_SIDE_STAND       equ 4
PHASE_SIDE_WALK_1      equ 5
PHASE_SIDE_WALK_2      equ 6

DIR_FACE    equ 0b000
DIR_BACK    equ 0b010
DIR_RIGHT   equ 0b001
DIR_LEFT    equ 0b011

hero_behaviour object_behaviour 0, 0, 0, map.draw_object
item_behaviour object_behaviour 0, item_turn, item_interact, draw_with_color
door_behaviour object_behaviour door_tick, door_turn, door_interact, draw_with_color
vdoor_behaviour object_behaviour door_tick, vdoor_turn, door_interact, map.draw_static_object
hero   object 1, 1, 0, res.girl, 0, res.girl, hero_behaviour
level_objects
    dw hero
    .32 dw 0

total_steps dw 0
adjacent_object dw 0

; Game object behaviours
interact:
    ld hl, (adjacent_object)
    ld a, h
    or a
    ret z

    ld a, object_behaviour.interact
    jp objects.call_behaviour ; call & ret

item_turn:
    ld ix, hl
    ld a, (ix + object.state + 1)
    ld b, a
    or a
    ret z ; already picked up

    ld a, (game.hero.x)
    sub (ix + object.x)

    inc a
    cp 3
    ret nc

    ld a, (game.hero.y)
    sub (ix + object.y)
    inc a
    cp 4
    ret nc

    ld (adjacent_object), hl
    ret

item_interact:
    ld ix, hl
    ld (ix + object.state + 1), 0
    ld (hl), 0xff ; hide
    ld a, (ix + object.state)
    call inventory.add_item
    ld hl, beeper.pickup_sound
    call beeper.play_sfx
    ld a, 1
    ld (dirty_screen), a
    ret

;; Game object behaviours
door_turn:
    ld ix, hl
    ld a, (ix + object.state)
    or a
    jr nz, .check_closing

    ld a, (game.hero.y) ; door.y - 1 <= y <= door.y + 1
    sub (hl)
    inc a
    cp 3
    ret nc

    inc hl
    ld a, (game.hero.x)
    cp (hl)
    ret nz

    dec hl
    ld (adjacent_object), hl

.check_closing
    cp 0xff
    ret nz

    ; -1, 0, 1

    ; keep open if
    ; -1 <= hero.y - door.y <= 1
    ld a, (game.hero.y)
    ld b, a
    ld a, (hl)
    and 0x7f ; the 7th bit is used for hiding
    sub b
    inc a
    cp 3
    jr nc, .start_closing

    ; keep open if
    ; -1 <= hero.x - door.x <= 1
    inc hl
    ld a, (game.hero.x)
    sub (hl)
    inc a
    cp 3
    ret c

.start_closing
    ld (ix + object.state), 0x87
    ld a, (ix)
    and 0x7f
    ld (ix), a ; unhide object
    ret
vdoor_turn:
    ld ix, hl
    ld a, (ix + object.state)
    or a
    jr nz, .check_closing

    ld a, (game.hero.y)
    cp (hl)
    ret nz

    inc hl
    ; activate if -2 <= game.hero.x - door.x <= 1
    ld a, (game.hero.x)
    sub (hl)
    add 2
    cp 4
    ret nc

    dec hl
    ld (adjacent_object), hl
    ret

.check_closing
    cp 0xff
    ret nz

    ; inc hl
    ld a, (hl)
    and 0x7f
    ld b, a
    ld a, (game.hero.y)
    cp b
    jr nz, .start_closing

    ; keep closed if -2 <= hero.x - door.x <= 1
    ; i.e. 0 <= hero.x - door.x + 2 <= 3
    ld a, (game.hero.x)
    inc hl
    sub (hl)
    add 2
    cp 4
    ret c

.start_closing
    ld (ix + object.state), 0x87
    ld a, (ix)
    and 0x7f
    ld (ix), a ; unhide object
    ret

    ; ld a, (hl)
    ; and 0x7f
    ; ld b, a
    ; ld a, (game.hero.x)
    ; ; close if not -1 <= door.x - game.hero.x <= 1
    ; and 0x7f
    ; sub (hl)
    ; inc a
    ; jr c, .start_closing

    ; inc hl
    ; ld a, (game.hero.y)
    ; cp


door_interact:
    ld ix, hl
    ld a, (ix + object.state)
    or a
    ret nz

    ld (ix + object.state), 1
    ret
door_tick:
    ld ix, hl
    ld a, (ix + object.state)
    or a
    ret z

    cp 0xff
    ret z

    bit 7, a
    jr z, .opening

.closing
    and 0x0f
    or a
    jr nz, 1F
    ; ld hl, i18n.door_closed
    ; call console.print_localized
    ld (ix + object.state), 0
    ld a, 1
    ld (dirty_screen), a
    ret

1
    bit 0, a
    jr z, 2F
    dec a
    or 0x80
    ld (ix + object.state), a
    ret

2
    dec a
    or 0x80
    ld (ix + object.state), a
    and 0x7f
    sra a
    call objects.update_sprite
    ret

.opening
    cp 5
    jr nz, 1F
    ; done opening, deactivate the door
    ; ld hl, i18n.door_open
    ; push ix
    ; call console.print_localized
    ; pop ix
    ld a, (ix)
    or 0x80
    ld (ix), a ; hide object by moving it off-screen
    ld (ix + object.state), 0xff
    ld a, 1
    ld (dirty_screen), a
    ret

1
    bit 0, a
    jr z, 2F
    inc a
    ld (ix + object.state), a
    ret

2
    inc a
    ld (ix + object.state), a
    sra a
    call objects.update_sprite
    ret


; hl - door object
draw_with_color:
    push hl
    ld bc, object.state + 1
    add hl, bc
    ld a, (hl)
    .3 dec hl
    ld b, (hl)
    inc hl
    ld h, (hl)
    ld l, b
    call sprite.paint_sprite_monochrome
    pop hl
    jp map.draw_static_object



; sets Z if no object found
find_next_drawable_object:
    ld hl, level_objects
    ld b, 0xff ; best y
    ld de, 0 ; best object

.loop
    ld c, (hl)
    inc hl
    ld a, (hl)
    or a
    jr z, .end_loop

    bit 7, a
    jr z, .next_object

    push de
    ld e, c
    ld d, a
    ld a, (de)
    cp b
    jr nc, .next_object_pop

    ld b, a ; new best y
    pop af ; discard the previous object from the stack
    ld ix, hl
    inc hl
    jr .loop
.next_object_pop
    pop de
.next_object
    inc hl
    jr .loop

.end_loop
    ld a, d
    or a  ; set Z if no object found
    ret z

    ex de, hl
    ld a, (ix)
    and 0x7f
    ld (ix), a
    ret
draw_objects:
    ld hl, level_objects
.draw_loop
    call find_next_drawable_object
    jr z, .clean
    ld a, object_behaviour.draw
    call objects.call_behaviour
    jr .draw_loop

.clean
    ld hl, level_objects
.clean_loop
    inc hl
    ld a, (hl)
    or a
    ret z
    or 0x80
    ld (hl), a
    inc hl
    jr .clean_loop

stop_hero:
    ld a, (hero.state)
    or a
    ret z

    xor a
    ld (hero.state), a
    ld a, (hero.state+1)   ; direction

    cp DIR_FACE
    jr nz, 1F

    xor a
    ld e, a
    jr .update

1
    cp DIR_BACK
    jr nz, 2F
    xor a
    ld e, PHASE_BACK_STAND
    jr .update

2
    ld e, PHASE_SIDE_STAND
    rra

.update
    ld ix, hero
    ; ld (ix + object.mirror), 0
    ld a, e
    call objects.update_sprite

    ld (ix + object.state), 0
    ret

    macro post_turn
    xor a
    ld (adjacent_object+1), a
    ld a, object_behaviour.turn
    ld hl, level_objects
    call objects.object_loop
    endm


move_hero_right:
    ld a, (hero.state + 1)
    cp DIR_RIGHT
    jr z, 1F

    ; init moving state
    xor a
    ld (hero.state), a
    xor a
    ld (hero.mirror), a

    ld a, DIR_RIGHT
    ld (hero.state + 1), a

    ld a, 1
    ld e, PHASE_SIDE_STAND
    jr .update

1
    ld a, (hero.state)
    and 0xf
    cp 1
    jr nz, 2F

    ld a, 2
    ld e, PHASE_SIDE_WALK_1
    jr .update

2
    ld hl, beeper.step_sound
    call beeper.play_sfx
    call map.move_hero_right
    call log_steps
    ld a, 1
    ld e, PHASE_SIDE_WALK_2

.update
    ld ix, hero
    ld (ix + object.state), a
    ld a, e
    call objects.update_sprite
    post_turn
    ret

move_hero_left:
    ld a, (hero.state + 1)
    cp DIR_LEFT
    jr z, 1F

    ; init moving state
    ld a, DIR_LEFT
    ld (hero.state + 1), a

    ld a, 1
    ld  (hero.mirror), a
    ld e, PHASE_SIDE_STAND
    jr .update

1
    ld a, (hero.state)
    and 0xf
    cp 1
    jr nz, 2F

    ld a, 2
    ld e, PHASE_SIDE_WALK_1
    jr .update

2
    ld hl, beeper.step_sound
    call beeper.play_sfx
    call map.move_hero_left
    call log_steps
    ld a, 1
    ld e, PHASE_SIDE_WALK_2

.update
    ld ix, hero
    ld (ix + object.state), a
    ld a, e
    call objects.update_sprite
    post_turn
    ret

move_hero_down:
    ld ix, hero

    ld a, (hero.state + 1)
    cp DIR_FACE
    jr z, 1F

    ; init moving state
    ld a, DIR_FACE
    ld (hero.state + 1), a

    xor a
    ld (hero.mirror), a
    inc a
    ld de, PHASE_FACE_STAND
    jr .update

1
    ld a, (hero.state)
    and 0xf
    cp 1
    jr nz, 2F

    ld a, 2
    ld de, PHASE_FACE_WALK
    jr .update

2
    ld hl, beeper.step_sound
    call beeper.play_sfx
    call map.move_hero_down
    call log_steps
    ld a, 1
    ld de, 0x100 + PHASE_FACE_WALK

.update
    ld (ix + object.state), a
    ld (ix + object.mirror), d
    ld a, e
    call objects.update_sprite
    post_turn
    ret

move_hero_up:
    ld ix, hero

    ld a, (hero.state + 1)
    cp DIR_BACK
    jr z, 1F

    ; init moving state
    ld a, DIR_BACK
    ld (hero.state + 1), a

    xor a
    ld (hero.mirror), a
    ld de, PHASE_BACK_STAND
    inc a
    jr .update

1
    ld a, (hero.state)
    and 0xf
    cp 1
    jr nz, 2F

    ld a, 2
    ld de, PHASE_BACK_WALK
    jr .update

2
    ld hl, beeper.step_sound
    call beeper.play_sfx
    call map.move_hero_up
    call log_steps
    ld a, 1
    ld de, 0x100 + PHASE_BACK_WALK

.update
    ld (ix + object.state), a
    ld (ix + object.mirror), d
    ld a, e
    call objects.update_sprite
    post_turn
    ret

log_steps:
    ret
	ld hl, game.total_steps
	inc (hl)
	ld hl, i18n.step
    push ix
    ld ix, default_console
	call console.println
    pop ix
    ret

; hl - level ref
; d - hero x, e - hero y
activate_level:
    di
    ld (game.hero), de

    ld e, (hl)
    inc hl
    ld d, (hl)
    inc hl
    push de
    ld de, CURRENT_MAP
    call dzx0_standard
    ld hl, CURRENT_MAP
    call map.set_current_map
    pop hl

    ld e, (hl)
    inc hl
    ld d, (hl)
    inc hl
    ex de, hl
    call map.set_tiles
    ex de, hl

    ld bc, 0
    push hl
.length
    inc hl
    bit 7,(hl)
    jr z, 1F
    inc c
    inc c
    inc hl
    jr .length

1
    pop hl
    ld de, level_objects
    ldir

    ex hl, de
    ld (hl), low(hero)
    inc hl
    ld (hl), high(hero)
    .2 inc hl
    ld (hl), 0

    call tiles.prepare_tiles
    call map.redraw_map
.end
    ei
    ret

level_1
    dw level_1_metadata
    incbin "res/gen/levels/test_level.zx0"

level_1_metadata
    dw res.tiles
    dw .door_1
    dw .door_2
    dw .door_3
    dw .vdoor_1
    dw .keycard
    dw 0

.door_1 object 8, 4, 0, res.door, 0x200, res.door, door_behaviour
.door_2 object 14, 4, 0, res.door, 0x500, res.door, door_behaviour
.door_3 object 14, 22, 0, res.door, 0x400, res.door, door_behaviour
.vdoor_1 object 6, 20, 0, res.vdoor, 0x4700, res.vdoor, vdoor_behaviour
.keycard object 6, 6, 0, res.keycard, 0x201, 0, item_behaviour

    endmodule

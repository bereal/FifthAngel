    module bullet

    struct bullet_state
y byte
x byte
y_d byte
row byte
sprite block 3
data block 8
move_proc word
    ends
bullet_1 bullet_state

bullets dw bullet_1, 0

; ix - bullet object
; hl - move proc
; bc - coord
; d - y_d
; a - initial row value
init_bullet:
    ld (ix + bullet_state.move_proc), hl
    ld hl, ix
    ld (hl), c
    inc hl
    ld (hl), b
    inc hl
    ld (hl), d
    inc hl
    ld (hl), a
    inc hl
    ld (hl), 7
    inc hl
    ld de, hl
    .2 inc de
    ld (hl), e
    inc hl
    ld (hl), d
    ret

bullet_tick:
    ld a, (hl)
    or a
    ret z

    ld ix, hl
    ld hl, (ix + bullet_state.move_proc)
    ld (.call + 1), hl

    call clear_bullet
.call
    call 0
    jr nc, .draw

    call bullet_collides
    jr nz, .hide

.draw
    call draw_bullet
    ret

.hide
    ld (ix), 0
    ret

bullet_loop:
    ld hl, bullets
.loop
    ld e, (hl)
    inc hl
    ld d, (hl)

    xor a
    or d
    ret z

    push hl
    ex de, hl
    call bullet_tick
    pop hl
    inc hl
    jr .loop

clear_bullet:
    ld bc, (ix)
    bit 7, c
    ret nz
    call map.coord_to_addr
    ret m
    xor a
    ld (hl), a
    ret

; set Z iff could not draw
draw_bullet:
    ld bc, (ix)
    bit 7, c
    ret nz
    push bc
    call update_bullet_data
    pop bc
    call map.coord_to_addr
    jp p, 1F
    xor a
    or a
    ret
1

    ld a, (hl)
    and 0x7f
    ret nz

    ex de, hl
    ld hl, ix
    ld bc, bullet_state.sprite
    add hl, bc
    .3 ldi
    ld a, 1
    ld (dirty_screen), a
    or a
    ret

; C is set if need to check collision
; ix bullet
move_bullet_right:
    ld a, (ix + bullet_state.row)
    .4 rrca
    ld (ix + bullet_state.row), a
    ld (dirty_screen), a
    ret nc

    call clear_bullet
    inc (ix + bullet_state.x)
    scf
    ret

move_bullet_left:
    ld bc, bullet_state.row
    add hl, bc
    ld a, (hl)
    .4 rlca
    ld (hl), a
    ld (dirty_screen), a
    ret nc

    call clear_bullet
    dec hl
    dec (hl)
    scf
    ret

; hl - bullet
move_bullet_down:
    ld bc, bullet_state.y_d
    add hl, bc
    ld a, (hl)
    add 2
    cp 7
    jr nc, .cell
    ld (hl), a
    ld (dirty_screen), a
    ccf
    ret

.cell
    ld (hl), 0
    call clear_bullet
    .2 dec hl
    inc (hl)
    scf
    ret

; hl - bullet
move_bullet_up:
    ld bc, bullet_state.y_d
    add hl, bc
    ld a, (hl)
    sub 2
    jr c, .cell
    ld (hl), a
    ld (dirty_screen), a
    ret

.cell
    ld (hl), 0
    call clear_bullet
    .2 dec hl
    inc (hl)
    scf
    ret

; NZ if collides
bullet_collides:
    ld bc, (ix)
    call map.coord_to_addr
    ld a, (hl)
    and 0x7f
    ret

; ix - bullet
shoot_right:
    ld ix, bullet_1
    ld a, (ix)
    or a
    ret nz

    ld hl, game.hero
    ld c, (hl)
    inc hl
    ld b, (hl)
    .2 inc b
    inc c
    push bc
    call map.coord_to_addr
    pop bc
    ret m
    ld a, (hl)
    and 0x7f
    ret nz

    ld a, 0xc0
    ld hl, move_bullet_right
    ld d, 3
    call init_bullet
    ret

; ix - bullet
shoot_right:
    ld ix, bullet_1
    ld a, (ix)
    or a
    ret nz

    ld hl, game.hero
    ld c, (hl)
    inc hl
    ld b, (hl)
    .2 inc b
    inc c
    push bc
    call map.coord_to_addr
    pop bc
    ret m
    ld a, (hl)
    and 0x7f
    ret nz

    ld a, 0xc0
    ld hl, move_bullet_right
    ld d, 3
    call init_bullet
    ret


; ix - bullet object
update_bullet_data:
    push hl
    push de
    push bc
    ld b, (ix + bullet_state.y_d)
    ld a, 6
    sub b
    ld c, a

    ld hl, ix
    ld de, bullet_state.data
    add hl, de

    ld a, b
    or a
    jr z, 2F

    xor a
1
    ld (hl), a
    inc hl
    djnz 1B

2
    ld a, (ix + bullet_state.row)

    ld (hl), a
    inc hl
    ld (hl), a
    inc hl

    ld a, c
    or a
    jr z, .end

    ld b, a
    xor a
3
    ld (hl), a
    inc hl
    djnz 3B

.end
    pop bc
    pop de
    pop hl
    ret

    endmodule
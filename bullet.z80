    module bullet

    struct bullet_state
distance byte
y byte
x byte
y_d byte
row byte
sprite block 3
data block 8
move_proc word
    ends

free_bullets db 3
bullets block bullet_state * 3, 0

find_bullet_slot:
    ld a, (free_bullets)
    or a
    ret z

    push hl
    push bc
    push de
    ld hl, bullets
    ld b, 3
    ld de, bullet_state

1
    ld a, (hl)
    or a
    jr z, .found

    add hl, de
    djnz 1B
    ret

.found
    ld ix, hl
    pop de
    pop bc
    pop hl
    inc a
    ret


; hl - move proc
; bc - coord
; d - y_d
; a - initial row value

; out: ix - bullet
; Z - if cannot allocate a bullet
init_bullet:
    ld (ix + bullet_state.move_proc), hl
    ld hl, ix
    ld (hl), 10
    inc hl
    ld (hl), c
    inc hl
    ld (hl), b
    inc hl
    ld (hl), d
    inc hl
    ld (hl), a
    inc hl
    ld (hl), 7
    inc hl
    ld de, hl
    .2 inc de
    ld (hl), e
    inc hl
    ld (hl), d
    ld hl, free_bullets
    dec (hl)
    ret

bullet_tick:
    dec (hl)
    jr z, .stop

    ld ix, hl
    ld hl, (ix + bullet_state.move_proc)
    ld (.call + 1), hl

    call clear_bullet
.call
    call 0
    jr nc, .draw

    call bullet_collides
    jr nz, .free

.draw
    call draw_bullet
    ret

.stop
    ld ix, hl
    call clear_bullet
.free
    call free_bullet
    ret

bullet_loop:
    ld a, (free_bullets)
    cp 3
    ret z

    ld hl, bullets
    ld b, 3
.loop
    ld a, (hl)
    or a
    jr z, .next

    push hl
    push bc
    call bullet_tick
    pop bc
    pop hl

.next
    ld de, bullet_state
    add hl, de
    djnz .loop
    ret

clear_bullet:
    ld bc, (ix + bullet_state.y)
    call map.coord_to_addr
    ret m
    xor a
    ld (hl), a
    inc a
    ld (dirty_screen), a
    ret

free_bullet:
    ld (ix), 0
    ld hl, free_bullets
    inc (hl)
    ret

; set Z iff could not draw
draw_bullet:
    ld bc, (ix + bullet_state.y)
    push bc
    call update_bullet_data
    pop bc
    call map.coord_to_addr
    jp p, 1F
    xor a
    or a
    ret
1

    ld a, (hl)
    and 0x7f
    ret nz

    ex de, hl
    ld hl, ix
    ld bc, bullet_state.sprite
    add hl, bc
    .3 ldi
    ld a, 1
    ld (dirty_screen), a
    or a
    ret

; C is set if need to check collision
; ix bullet
move_bullet_right:
    ld a, (ix + bullet_state.row)
    .4 rrca
    ld (ix + bullet_state.row), a
    ld (dirty_screen), a
    ret nc

    call clear_bullet
    inc (ix + bullet_state.x)
    scf
    ret

move_bullet_left:
    ld a, (ix + bullet_state.row)
    .4 rlca
    ld (ix + bullet_state.row), a
    ld (dirty_screen), a
    ret nc

    call clear_bullet
    dec (ix + bullet_state.x)
    scf
    ret

; hl - bullet
move_bullet_down:
    ld bc, bullet_state.y_d
    add hl, bc
    ld a, (hl)
    add 2
    cp 7
    jr nc, .cell
    ld (hl), a
    ld (dirty_screen), a
    ccf
    ret

.cell
    ld (hl), 0
    call clear_bullet
    .2 dec hl
    inc (hl)
    scf
    ret

; hl - bullet
move_bullet_up:
    ld bc, bullet_state.y_d
    add hl, bc
    ld a, (hl)
    sub 2
    jr c, .cell
    ld (hl), a
    ld (dirty_screen), a
    ret

.cell
    ld (hl), 0
    call clear_bullet
    .2 dec hl
    inc (hl)
    scf
    ret

; NZ if collides
bullet_collides:
    ld bc, (ix + bullet_state.y)
    call map.coord_to_addr
    ld a, (hl)
    and 0x7f
    ret

; ix - bullet
shoot_right:
    call find_bullet_slot
    ret z

    ld hl, game.hero
    ld c, (hl)
    inc hl
    ld b, (hl)
    .2 inc b
    inc c
    push bc
    call map.coord_to_addr
    pop bc
    ret m
    ld a, (hl)
    and 0x7f
    ret nz

    ld a, 0xc0
    ld hl, move_bullet_right
    ld d, 3
    call init_bullet
    ret

; ix - bullet object
shoot_left:
    call find_bullet_slot
    ret z

    ld hl, game.hero
    ld c, (hl)
    inc hl
    ld b, (hl)
    dec b
    inc c
    push bc
    call map.coord_to_addr
    pop bc
    ret m
    ld a, (hl)
    and 0x7f
    ret nz

    ld a, 3
    ld d, a
    ld hl, move_bullet_left
    call init_bullet
    ret

update_bullet_data:
    push hl
    push de
    push bc
    ld b, (ix + bullet_state.y_d)
    ld a, 6
    sub b
    ld c, a

    ld hl, ix
    ld de, bullet_state.data
    add hl, de

    ld a, b
    or a
    jr z, 2F

    xor a
1
    ld (hl), a
    inc hl
    djnz 1B

2
    ld a, (ix + bullet_state.row)

    ld (hl), a
    inc hl
    ld (hl), a
    inc hl

    ld a, c
    or a
    jr z, .end

    ld b, a
    xor a
3
    ld (hl), a
    inc hl
    djnz 3B

.end
    pop bc
    pop de
    pop hl
    ret

    endmodule